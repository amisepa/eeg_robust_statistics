%% LIMO HLM step by step
%
% Cedric Cannard, Sep 2022

clear; close all; clc;
folder = 'G:\My Drive\HLM\limo';
addpath('G:\My Drive\HLM')
eeglab; close;

% add paths
root = fileparts(which('limo_eeg'));
addpath([root filesep 'limo_cluster_functions']);
addpath([root filesep 'external' filesep 'psom']);
addpath([root filesep 'external']);
addpath([root filesep 'help']);
ftPath = fileparts(which('ft_analysispipeline.m'));
addpath(fullfile(ftPath, 'external','signal'))
addpath(fullfile(ftPath, 'external','stats'))
addpath(fullfile(ftPath, 'external','images'))

% load small test study (PSD precomputed)
[STUDY, ALLEEG] = pop_loadstudy('filename','test.study','filepath',folder);

%% Parameters

% [STUDY,limofiles] = std_limo(STUDY, ALLEEG, options{:});
LIMO_files = [];
cd(STUDY.filepath);
opt.method = 'WLS';                 % 'OLS', 'IRLS', 'WLS' (default)
opt.measure = 'datspec';            % 'daterp', 'datspec', 'dattimef', 'icaerp', 'icaspec', 'icatimef'
opt.design = STUDY.currentdesign;   % default = 1
opt.erase = 'on';                   % default = 1
opt.splitreg = 'off';               % default = off
opt.interaction = 'on';             % default = off
opt.freqlim = [1 15];               % default = [], [1 30]
opt.timelim = [];                   % default = [], [-150 1000]
opt.chanloc = struct('no', {});     % default = struct('no', {})
opt.neighboropt = {};               % default = {}
opt.neighbormat = [];               % default = []
opt.zscore = 1;                     % 0 or 1 (default)
opt.ow_chanlocfile = 'no';          % 'yes' or 'no' (default)

if strcmpi(opt.measure, 'datersp')
    opt.measure = 'dattimef';
end
Analysis     = opt.measure;
design_index = opt.design;
model.defaults.datatype = Analysis(4:end);
model.defaults.type = 'Channels';

%% Find channel neighbors

% if isempty(opt.chanloc) && isempty(opt.neighbormat)
if ~isfield(ALLEEG(1).chanlocs, 'theta')
    error('EEG files must have channel locations.')
end

cfg.elec.elecpos(:,1) = [ ALLEEG(1).chanlocs.X ];
cfg.elec.elecpos(:,2) = [ ALLEEG(1).chanlocs.Y ];
cfg.elec.elecpos(:,3) = [ ALLEEG(1).chanlocs.Z ];
cfg.elec.label = { ALLEEG(1).chanlocs.labels };
cfg.label = { ALLEEG(1).chanlocs.labels };
cfg.method = 'triangulation';

% find channel neighbors
data = cfg;
cfg  = rmfield(cfg, 'label');     % first input must not be data
data = rmfield(data, 'method');   % second input must not be method

% neighbors = ft_prepare_neighbours(cfg, data); %%% TO EXTRACT
cfg.feedback = 'no';
cfg.channel  = 'all';
cfg.compress = 'yes';
cfg.parcellation = 'parcellation';

% check if the input data is valid for this function
data = ft_checkdata(data);

% set the default for senstype depending on the data
cfg.senstype = ft_getopt(cfg, 'senstype', 'eeg');

% get 3D positions from the sensor description
sens = ft_fetch_sens(cfg, data);
chanpos = sens.chanpos;
label   = sens.label;

% remove channels that are not in data
[dum, sensidx] = match_str(data.label, label);
chanpos = chanpos(sensidx, :);
label   = label(sensidx);

% select the desired channels
desired = ft_channelselection(cfg.channel, label);
[sensidx] = match_str(label, desired);
chanpos = chanpos(sensidx, :);
label   = label(sensidx);

% Project sensor positions on 2D plane if not already the case
if size(chanpos, 2) == 2 || all( chanpos(:,3) == 0 )
    proj = chanpos(:,1:2); % already on a 2D plane
else
    % project sensor on a 2D plane (from function elproj)
    x = chanpos(:,1);
    y = chanpos(:,2);
    if size(chanpos, 2) == 3
        z = chanpos(:,3);
    end
    
    % use default polar (angular) projection
    [az, el, r] = cart2sph(x, y, z);
    [x, y] = pol2cart(az, pi/2 - el);
    proj = [x, y];
end

% make a 2d Delaunay triangulation of the projected points
tri = delaunay(proj(:,1), proj(:,2));
if strcmp(cfg.compress, 'yes')
    tri_x = delaunay(proj(:,1)./2, proj(:,2)); % compress in the x-direction
    tri_y = delaunay(proj(:,1), proj(:,2)./2); % compress in the y-direction
    tri = [tri; tri_x; tri_y];
end

% Compute the neighbourhood geometry from the gradiometer/electrode positions
% neighbors = compneighbstructfromtri(chanpos, label, tri);
nchan = length(label);

% mark neighbors according to triangulation
channeighbstructmat = zeros(nchan,nchan);
for i = 1:size(tri, 1)
    channeighbstructmat(tri(i, 1), tri(i, 2)) = 1;
    channeighbstructmat(tri(i, 1), tri(i, 3)) = 1;
    channeighbstructmat(tri(i, 2), tri(i, 1)) = 1;
    channeighbstructmat(tri(i, 3), tri(i, 1)) = 1;
    channeighbstructmat(tri(i, 2), tri(i, 3)) = 1;
    channeighbstructmat(tri(i, 3), tri(i, 2)) = 1;
end

% construct a structured cell-array with all neighbors
neighbors = struct;
alldist = [];
for i = 1:nchan
    neighbors(i).label       = label{i};
    neighbidx                 = find(channeighbstructmat(i,:));
    neighbors(i).dist        = sqrt(sum((repmat(chanpos(i, :), numel(neighbidx), 1) - chanpos(neighbidx, :)).^2, 2));
    alldist                   = [alldist; neighbors(i).dist];
    neighbors(i).neighblabel = label(neighbidx);
end

% remove neighbouring channels that are too far away (IMPORTANT if missing sensors)
neighbdist = mean(alldist)+3*std(alldist);
for i=1:nchan
    idx = neighbors(i).dist > neighbdist;
    neighbors(i).dist(idx)         = [];
    neighbors(i).neighblabel(idx)  = [];
end
neighbors = rmfield(neighbors, 'dist');

% Only select channels that are in the data
% if isfield(cfg, 'channel') && ~isempty(cfg.channel)
% %     desired = ft_channelselection(cfg.channel, data.label);
%     desired = data.label;
% end
% complete = struct;
% for i = 1:numel(desired)
% complete(i).label = desired{i};
% sel = find(strcmp({neighbors(:).label}, desired{i}));
% if numel(sel)==1
%   % take the set of neighbors from the definition
%   complete(i).neighblabel = neighbors(sel).neighblabel;
% else
%   % there are no neighbors defined for this channel
%   complete(i).neighblabel = {};
% end
% end
% neighbors = complete;

% Convert neighbors into row-arrays for a nicer code representation
% for i = 1:length(neighbors)
%   neighbors(i).neighblabel = neighbors(i).neighblabel(:)';
% end

% check that all chans have neighbors
k = 0;
for i = 1:length(neighbors)
    if isempty(neighbors(i).neighblabel)
        warning('no neighbors found for %s', neighbors(i).label);
    end
    k = k + length(neighbors(i).neighblabel);
end
if k==0
    warning('No neighbouring channels were specified or found');
else
    fprintf('there are on average %.1f neighbors per channel\n', k/length(neighbors));
end

% visual feedback (or try convert_3dto2d for eeglab topo with nose and labels)
tmpcfg = keepfields(cfg, {'layout', 'rows', 'columns', 'commentpos', 'skipcomnt', ...
    'scalepos', 'skipscale', 'projection', 'viewpoint', 'rotate', 'width', 'height', ...
    'elec', 'grad', 'opto', 'showcallinfo', 'trackcallinfo', 'trackconfig', ...
    'trackusage', 'trackdatainfo', 'trackmeminfo', 'tracktimeinfo'});
tmpcfg.neighbors = neighbors;
tmpcfg.senstype = cfg.senstype;
ft_neighbourplot(tmpcfg, data);

% Convert to limo format
% STUDY.etc.statistics.fieldtrip.channelneighbor = neighbors;
limostruct.expected_chanlocs = ALLEEG(1).chanlocs;
limostruct.channeighbstructmat = zeros(ALLEEG(1).nbchan);
for i = 1:length(neighbors)
    [tmp, posChan] = intersect(cfg.elec.label, neighbors(i).neighblabel);
    limostruct.channeighbstructmat(i,posChan) = 1;
    limostruct.channeighbstructmat(posChan,i) = 1;
end
limoChanlocs = limostruct;
chanlocname = 'limo_gp_level_chanlocs.mat';

% save chanlocs
mkdir([STUDY.filepath filesep 'derivatives']);
limoChanlocsFile = fullfile([STUDY.filepath filesep 'derivatives'], chanlocname);
save('-mat', limoChanlocsFile, '-struct', 'limoChanlocs');
fprintf('Saving channel neighbors for correction for multiple comparisons in \n%s\n', limoChanlocsFile);

%% 1st level analysis

model.cat_files  = [];
model.cont_files = [];

% % Cleaning old files from the current design (Cleaning ALL)
% if strcmp(opt.erase,'on')
%     [~,filename] = fileparts(STUDY.filename);
%     std_limoerase(STUDY.filepath, filename, STUDY.subject, num2str(STUDY.currentdesign));
%     STUDY.limo = [];
% end

% % Check if the measures has been computed
% % also find out if the channels are interpolated
% % -------------------------------------------------------------------------
% interpolated = zeros(1,length(STUDY.datasetinfo));
% for iDat = 1:length(STUDY.datasetinfo)
%     fileName = fullfile(STUDY.datasetinfo(iDat).filepath, [ STUDY.datasetinfo(iDat).subject '*.' opt.measure ]);
%     % fileName should already match unless user moves / rename, hence using dir
%     fileName = dir(fileName);
%     if isempty(fileName)
%         error('std_limo subject %s: Measures must be computed first',STUDY.datasetinfo(iDat).subject);
%     else
%         if strcmp(model.defaults.type,'Channels')
%             tmpChans = load('-mat', fullfile(fileName(1).folder,fileName(1).name), 'labels');
%             if length(tmpChans.labels) > ALLEEG(iDat).nbchan, interpolated(iDat) = 1; end
%         end
%     end
% end
% measureflags = struct('daterp','off',...
%     'datspec','off',...
%     'datersp','off',...
%     'dattimef','off',...
%     'datitc' ,'off',...
%     'icaerp' ,'off',...
%     'icaspec','off',...
%     'icatimef','off',...
%     'icaersp','off',...
%     'icaitc','off');
% measureflags.(lower(opt.measure))= 'on';
% STUDY.etc.measureflags = measureflags;
% mergedChanlocs = eeg_mergelocs(ALLEEG.chanlocs);
STUDY.etc.datspec = 'on';
mergedChanlocs = {ALLEEG()}
fprintf('generating temporary files, pulling relevant trials ... \n')



